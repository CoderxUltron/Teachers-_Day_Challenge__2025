TODAY I TACKELED TWO LEETCODE QUESTION :

1) Merge Intervals
2) Maximum Depth of Binary Tree


PROBLEM 1 :

56. Merge Intervals : 

Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.


Language : Java 

CODE :

class Solution {
    public int[][] merge(int[][] intervals) {
        
        if (intervals.length <=1) {
        return intervals;
        }

        Arrays.sort(intervals , Comparator.comparingInt( i -> i[0]));

        List<int[]> result = new ArrayList<>();

        int[] newInterval = intervals[0];
        result.add(newInterval);

        for( int[] interval : intervals ){

            if( interval[0]<= newInterval[1]){
                newInterval[1] = Math.max( newInterval[1], interval[1]);
            }
            else{
                newInterval = interval ; 
                result.add(newInterval);
            }
        }
        return result.toArray(new int[result.size()][]);
    }
}


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


PROBLEM 2 :

104. Maximum Depth of Binary Tree :

Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.


Language : Java 


CODE  : 

class Solution {
    public int maxDepth(TreeNode root) {

         if (root == null) {
            return 0;
        }        

        Queue<TreeNode> queue = new LinkedList<>();

        queue.add(root);
        int level = 0;

        while (!queue.isEmpty()) {
            int nNodes = queue.size();

            while(nNodes > 0) {
                TreeNode node = queue.poll();

                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }

                nNodes--;
            }
            level++;
        }
        return level;
    }
    
 }



